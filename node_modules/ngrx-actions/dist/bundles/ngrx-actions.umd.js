(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/operators'), require('@ngrx/store')) :
	typeof define === 'function' && define.amd ? define('ngrx-actions', ['exports', '@angular/core', 'rxjs/operators', '@ngrx/store'], factory) :
	(factory((global['ngrx-actions'] = {}),global.ng.core,global.Rx.Observable.prototype,global.store));
}(this, (function (exports,core,operators,store) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */









function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var NgrxSelect = /** @class */ (function () {
    function NgrxSelect() {
    }
    NgrxSelect.prototype.connect = function (store$$1) {
        NgrxSelect.store = store$$1;
    };
    return NgrxSelect;
}());
NgrxSelect.store = undefined;
NgrxSelect.decorators = [
    { type: core.Injectable },
];
NgrxSelect.ctorParameters = function () { return []; };
function Select(selectorOrFeature) {
    var paths = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        paths[_i - 1] = arguments[_i];
    }
    return function (target, name) {
        var selectorFnName = '__' + name + '__selector';
        var fn;
        if (!selectorOrFeature) {
            selectorOrFeature = name;
        }
        if (typeof selectorOrFeature === 'string') {
            var propsArray = paths.length ? __spread([selectorOrFeature], paths) : selectorOrFeature.split('.');
            fn = fastPropGetter(propsArray);
        }
        else {
            fn = selectorOrFeature;
        }
        var createSelect = function () {
            var store$$1 = NgrxSelect.store;
            if (!store$$1) {
                throw new Error('NgrxSelect not connected to store!');
            }
            return store$$1.select(fn);
        };
        if (target[selectorFnName]) {
            throw new Error('You cannot use @Select decorator and a ' + selectorFnName + ' property.');
        }
        if (delete target[name]) {
            Object.defineProperty(target, selectorFnName, {
                writable: true,
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(target, name, {
                get: function () {
                    return this[selectorFnName] || (this[selectorFnName] = createSelect.apply(this));
                },
                enumerable: true,
                configurable: true
            });
        }
    };
}
function fastPropGetter(paths) {
    var segments = paths;
    var seg = 'store.' + segments[0], i = 0;
    var l = segments.length;
    var expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    var fn = new Function('store', 'return ' + expr + ';');
    return (fn);
}
var NGRX_ACTIONS_META = '__ngrx__actions__';
function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(NGRX_ACTIONS_META)) {
        var defaultMetadata = { actions: {}, effects: {} };
        Object.defineProperty(target, NGRX_ACTIONS_META, { value: defaultMetadata });
    }
    return target[NGRX_ACTIONS_META];
}
function createReducer(store$$1) {
    var isInstance = !store$$1.prototype;
    var klass = isInstance ? store$$1.constructor : store$$1;
    if (!klass.hasOwnProperty(NGRX_ACTIONS_META)) {
        throw new Error('A reducer can be created from a @Store decorated class only.');
    }
    var instance = isInstance ? store$$1 : new store$$1();
    var _a = (klass[NGRX_ACTIONS_META]), initialState = _a.initialState, actions = _a.actions, effects = _a.effects;
    return function (state, action) {
        if (state === void 0) { state = initialState; }
        var actionMeta = actions[action.type];
        if (actionMeta) {
            var result = instance[actionMeta.fn](state, action);
            if (result === undefined) {
                if (Array.isArray(state)) {
                    return __spread(state);
                }
                else {
                    return Object.assign({}, state);
                }
            }
            state = result;
        }
        var effectMeta = effects[action.type];
        if (effectMeta) {
            var retVal = instance[effectMeta.fn](state, action);
            if (retVal) {
                if (retVal.subscribe) {
                    retVal.pipe(operators.materialize()).subscribe(function (res) {
                        if (res.value && NgrxSelect.store) {
                            NgrxSelect.store.dispatch(res.value);
                        }
                    });
                }
                else if (NgrxSelect.store) {
                    if (Array.isArray(retVal)) {
                        retVal.forEach(function (r) { return NgrxSelect.store && NgrxSelect.store.dispatch(r); });
                    }
                    else {
                        NgrxSelect.store.dispatch(retVal);
                    }
                }
            }
        }
        return state;
    };
}
var STORE_TOKEN = new core.InjectionToken('STORE_TOKEN');
var FEATURE_STORE_TOKEN = new core.InjectionToken('FEATURE_STORE_TOKEN');
var NgrxActionsModule = /** @class */ (function () {
    function NgrxActionsModule(reducers, featureReducers, reducerFactory, store$$1, parentInjector, select) {
        select.connect(store$$1);
        if (reducers) {
            for (var key in reducers) {
                var klass = reducers[key];
                var inst = parentInjector.get(klass, new klass());
                reducerFactory.addReducer(key, createReducer(inst));
            }
        }
        if (featureReducers) {
            if (typeof featureReducers.key !== 'string') {
                featureReducers.reducers = featureReducers.key;
                featureReducers.key = undefined;
            }
            var mapped = {};
            for (var key in featureReducers.reducers) {
                var klass = featureReducers.reducers[key];
                var inst = parentInjector.get(klass, new klass());
                mapped[key] = createReducer(inst);
            }
            if (featureReducers.key) {
                reducerFactory.addFeature({
                    reducers: mapped,
                    reducerFactory: (store.combineReducers),
                    key: featureReducers.key
                });
            }
        }
    }
    NgrxActionsModule.forRoot = function (reducers) {
        return {
            ngModule: NgrxActionsModule,
            providers: [
                {
                    provide: STORE_TOKEN,
                    useValue: reducers
                }
            ]
        };
    };
    NgrxActionsModule.forFeature = function (key, reducers) {
        return {
            ngModule: NgrxActionsModule,
            providers: [
                {
                    provide: FEATURE_STORE_TOKEN,
                    useValue: { key: key, reducers: reducers }
                }
            ]
        };
    };
    return NgrxActionsModule;
}());
NgrxActionsModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [store.StoreModule],
                providers: [NgrxSelect]
            },] },
];
NgrxActionsModule.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [STORE_TOKEN,] },] },
    { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [FEATURE_STORE_TOKEN,] },] },
    { type: store.ReducerManager, },
    { type: store.Store, },
    { type: core.Injector, },
    { type: NgrxSelect, },
]; };
function Action() {
    var actionsKlasses = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        actionsKlasses[_i] = arguments[_i];
    }
    return function (target, name, descriptor) {
        var meta = ensureStoreMetadata(target.constructor);
        try {
            for (var actionsKlasses_1 = __values(actionsKlasses), actionsKlasses_1_1 = actionsKlasses_1.next(); !actionsKlasses_1_1.done; actionsKlasses_1_1 = actionsKlasses_1.next()) {
                var klass = actionsKlasses_1_1.value;
                var inst = new klass();
                var type = inst.type;
                if (meta.actions[type]) {
                    throw new Error("@Action for '" + type + "' is defined multiple times in functions '" + meta.actions[type].fn + "' and '" + name + "'");
                }
                meta.actions[type] = {
                    action: klass,
                    fn: name,
                    type: type
                };
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (actionsKlasses_1_1 && !actionsKlasses_1_1.done && (_a = actionsKlasses_1.return)) _a.call(actionsKlasses_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var e_1, _a;
    };
}
function ofAction() {
    var allowedTypes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        allowedTypes[_i] = arguments[_i];
    }
    var allowedMap = {};
    allowedTypes.forEach(function (klass) { return (allowedMap[new klass().type] = true); });
    return operators.filter(function (action) {
        return allowedMap[action.type];
    });
}
function Store$1(initialState) {
    if (initialState === void 0) { initialState = {}; }
    return function (target) {
        var meta = ensureStoreMetadata(target);
        meta.initialState = initialState;
    };
}
function Effect() {
    var effectKlasses = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        effectKlasses[_i] = arguments[_i];
    }
    return function (target, name, descriptor) {
        var meta = ensureStoreMetadata(target.constructor);
        try {
            for (var effectKlasses_1 = __values(effectKlasses), effectKlasses_1_1 = effectKlasses_1.next(); !effectKlasses_1_1.done; effectKlasses_1_1 = effectKlasses_1.next()) {
                var klass = effectKlasses_1_1.value;
                var inst = new klass();
                var type = inst.type;
                if (meta.effects[type]) {
                    throw new Error("@Effect for '" + type + "' is defined multiple times in functions '" + meta.effects[type].fn + "' and '" + name + "'");
                }
                meta.effects[type] = {
                    action: klass,
                    fn: name,
                    type: type
                };
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (effectKlasses_1_1 && !effectKlasses_1_1.done && (_a = effectKlasses_1.return)) _a.call(effectKlasses_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var e_2, _a;
    };
}

exports.NgrxActionsModule = NgrxActionsModule;
exports.Action = Action;
exports.ofAction = ofAction;
exports.Store = Store$1;
exports.Select = Select;
exports.NgrxSelect = NgrxSelect;
exports.createReducer = createReducer;
exports.Effect = Effect;
exports.ɵb = FEATURE_STORE_TOKEN;
exports.ɵa = STORE_TOKEN;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngrx-actions.umd.js.map
